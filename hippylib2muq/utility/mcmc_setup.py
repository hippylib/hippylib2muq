#  hIPPYlib-MUQ interface for large-scale Bayesian inverse problems
#  Copyright (c) 2019-2020, The University of Texas at Austin,
#  University of California--Merced, Washington University in St. Louis,
#  The United States Army Corps of Engineers, Massachusetts Institute of Technology

#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.

#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.

#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
import muq.SamplingAlgorithms as ms

def generate_MHoptions():
    """
    Generate options for MUQ Metropolis–Hastings algorithms
    """
    opts = dict()
    opts["BurnIn"] = 0
    opts["NumSamples"] = 0
    opts["PrintLevel"] = 2
    opts["Beta"] = 0
    opts["StepSize"] = 0
    return opts


def generate_DILIoptions():
    """
    Generate options for MUQ DILI algorithms
    """
    opts = dict()
    opts["BurnIn"] = 0
    opts["NumSamples"] = 0
    opts["PrintLevel"] = 2
    opts["HessianType"] = "GaussNewton"
    # How often the LIS should be adapted.
    # If negative, the LIS computed at the intial point will be used and held constant
    opts["Adapt Interval"] = -1
    opts["Prior Node"] = "Prior"
    opts["Likelihood Node"] = "Likelihood"

    # Options for the transition kernel employed in the LIS
    lisOpts = dict()
    lisOpts["Method"] = "MHKernel"
    lisOpts["Proposal"] = "PropOpts"
    lisOpts["PropOpts.Method"] = "MALAProposal"
    lisOpts["PropOpts.StepSize"] = 0

    opts["LIS Block"] = "LIS"  # Dictionary key where the LIS options are specified
    opts["LIS"] = lisOpts

    # Options for the transition kernel employed in the CS
    csOpts = dict()
    csOpts["Method"] = "MHKernel"
    csOpts["Proposal"] = "PropOpts"
    csOpts["PropOpts.Method"] = "CrankNicolsonProposal"
    csOpts["PropOpts.Beta"] = 0
    csOpts["PropOpts.PriorNode"] = "Prior"

    opts["CS Block"] = "CS"  # Dictionary key where the CS options are specified
    opts["CS"] = csOpts

    return opts

def setup_proposal(propName, options, problem, propGaussian):
    """
    Set up the MUQ MCMC proposal.

    :param propName: "pcn" : preconditioned Crank-Nicolson
                     "mala" : Metropolis adjusted Langevin algorithms
                     "inf_mala" : infinite-dimensional version of "mala"
                     "dr" : delayed rejection (here, we use first "pcn" and
                     then "mala")
                     "dr_inf" : infinite-dimensional version of "dr" (here, we
                     use first "pcn" and then "inf_mala")
    :param options: options generated by generate_MHoptions()
    :param problem: instance of ms.SamplingProblem()
    :param propGaussian: Gaussian distribution used as proposal
    """
    if propName == "pcn":
        proposal = ms.CrankNicolsonProposal(options, problem, propGaussian)
    elif propName == "mala":
        proposal = ms.MALAProposal(options, problem, propGaussian)
    elif propName == "inf_mala":
        proposal = ms.InfMALAProposal(options, problem, propGaussian)
    elif propName == "dr":
        proposal = [
            ms.CrankNicolsonProposal(options, problem, propGaussian[0]),
            ms.MALAProposal(options, problem, propGaussian[1]),
        ]
    elif propName == "dr_inf":
        proposal = [
            ms.CrankNicolsonProposal(options, problem, propGaussian[0]),
            ms.InfMALAProposal(options, problem, propGaussian[1]),
        ]
    return proposal


def setup_kernel(kernName, options, problem, proposal):
    """
    Set up the MUQ MCMC kernel

    :param kernName: "mh" : Metropolis–Hasting kernel
                     "dr" : Delayed rejection kernel
    :param options: options generated by generate_MHoptions()
    :param problem: instance of ms.SamplingProblem()
    :param proposal: MUQ MCMC proposals
    """
    if kernName == "mh":
        kernel = ms.MHKernel(options, problem, proposal)
    elif kernName == "dr":
        kernel = ms.DRKernel(options, problem, proposal, [1.0] * len(proposal))

    return kernel


def run_MCMC(options, kernel, startpoint, dili=False):
    """
    Run MUQ MCMC simulation

    :param options: options for running MUQ MCMC
    :param kernel: MUQ MCMC kernel
    :param startpoint: the initial parameter vector
    """
    # Construct the MCMC sampler
    sampler = ms.SingleChainMCMC(options, [kernel])

    # Run the MCMC sampler
    samples = sampler.Run([startpoint])

    if "AcceptanceRate" in dir(kernel):
        return samples, kernel.AcceptanceRate(), sampler.TotalTime()
    elif "AcceptanceRates" in dir(kernel):
        return samples, kernel.AcceptanceRates(), sampler.TotalTime()
    elif dili:
        return (
            samples,
            [kernel.LISKernel().AcceptanceRate(), kernel.CSKernel().AcceptanceRate()],
            sampler.TotalTime(),
        )

